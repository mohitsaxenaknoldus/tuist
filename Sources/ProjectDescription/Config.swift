import Foundation

/// This model allows to configure Tuist.
public struct Config: Codable, Equatable {
    /// Contains options related to the project generation.
    public enum GenerationOptions: Codable, Equatable {
        /// Contains options for autogenerated targets
        public enum AutogenerationOptions: Codable, Equatable {
            /// Contains options for code coverage
            public enum CodeCoverageMode: Codable, Equatable {
                /// Gather code coverage for all targets
                case all
                /// Gather code coverage only for targets, that have code coverage enabled at least in one scheme
                case relevant
                /// Gather code coverage only for given targets
                case targets([TargetReference])
                /// Do not gather code coverage
                case disabled
            }

            /// Tuist will not automatically generate any schemes
            case disabled
            /// Tuist will generate schemes with the associated testing options
            case enabled(codeCoverageMode: CodeCoverageMode = .disabled, testingOptions: TestingOptions = [])
        }

        /// Tuist generates the project with the specific name on disk instead of using the project name.
        case xcodeProjectName(TemplateString)

        /// Tuist generates the project with the specific organization name.
        case organizationName(String)

        /// Tuist generates the project with the specific development region.
        case developmentRegion(String)

        /// Options controlling how / if Tuist automatically generates the workspace scheme.
        /// Default value when not set is `.autogeneratedWorkspaceOptions(.enabled([]))`
        case autogeneratedWorkspaceSchemes(AutogenerationOptions)

        /// Tuist disables echoing the ENV in shell script build phases
        case disableShowEnvironmentVarsInScriptPhases

        /// When passed, Xcode will resolve its Package Manager dependencies using the system-defined
        /// accounts (e.g. git) instead of the Xcode-defined accounts
        case resolveDependenciesWithSystemScm

        /// Disables locking Swift packages. This can speed up generation but does increase risk if packages are not locked
        /// in their declarations.
        case disablePackageVersionLocking

        /// Allows to suppress warnings in Xcode about updates to recommended settings added in or below the specified Xcode version. The warnings appear when Xcode version has been upgraded.
        /// It is recommended to set the version option to Xcode's version that is used for development of a project, for example `.lastUpgradeCheck(Version(13, 0, 0))` for Xcode 13.0.0.
        case lastXcodeUpgradeCheck(Version)
    }

    /// Generation options.
    public let generationOptions: [GenerationOptions]

    /// List of Xcode versions that the project supports.
    public let compatibleXcodeVersions: CompatibleXcodeVersions

    /// List of `Plugin`s used to extend Tuist.
    public let plugins: [PluginLocation]

    /// Cloud configuration.
    public let cloud: Cloud?

    /// Cache configuration.
    public let cache: Cache?

    /// The version of Swift that will be used by Tuist.
    /// If `nil` is passed then Tuist will use the environmentâ€™s version.
    public let swiftVersion: Version?

    /// Initializes the tuist configuration.
    ///
    /// - Parameters:
    ///   - compatibleXcodeVersions: List of Xcode versions the project is compatible with.
    ///   - cloud: Cloud configuration.
    ///   - cache: Cache configuration.
    ///   - swiftVersion: The version of Swift that will be used by Tuist.
    ///   - plugins: A list of plugins to extend Tuist.
    ///   - generationOptions: List of options to use when generating the project.
    public init(
        compatibleXcodeVersions: CompatibleXcodeVersions = .all,
        cloud: Cloud? = nil,
        cache: Cache? = nil,
        swiftVersion: Version? = nil,
        plugins: [PluginLocation] = [],
        generationOptions: [GenerationOptions] = []
    ) {
        self.compatibleXcodeVersions = compatibleXcodeVersions
        self.plugins = plugins
        self.generationOptions = generationOptions
        self.cloud = cloud
        self.cache = cache
        self.swiftVersion = swiftVersion
        dumpIfNeeded(self)
    }
}

// MARK: - GenerationOptions + Codable

extension Config.GenerationOptions {
    internal enum CodingKeys: String, CodingKey {
        case xcodeProjectName
        case organizationName
        case developmentRegion
        case autogeneratedWorkspaceSchemes
        case disableShowEnvironmentVarsInScriptPhases
        case enableCodeCoverage
        case resolveDependenciesWithSystemScm
        case disablePackageVersionLocking
        case lastXcodeUpgradeCheck
    }

    // swiftlint:disable:next function_body_length
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if container.allKeys.contains(.xcodeProjectName), try container.decodeNil(forKey: .xcodeProjectName) == false {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .xcodeProjectName)
            let templateProjectName = try associatedValues.decode(TemplateString.self)
            self = .xcodeProjectName(templateProjectName)
        } else if container.allKeys.contains(.organizationName), try container.decodeNil(forKey: .organizationName) == false {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .organizationName)
            let organizationName = try associatedValues.decode(String.self)
            self = .organizationName(organizationName)
        } else if container.allKeys.contains(.developmentRegion), try container.decodeNil(forKey: .developmentRegion) == false {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .developmentRegion)
            let developmentRegion = try associatedValues.decode(String.self)
            self = .developmentRegion(developmentRegion)
        } else if container.allKeys.contains(.autogeneratedWorkspaceSchemes) {
            let autogenerationOptions = try container.decode(AutogenerationOptions.self, forKey: .autogeneratedWorkspaceSchemes)
            self = .autogeneratedWorkspaceSchemes(autogenerationOptions)
        } else if container.allKeys.contains(.disableShowEnvironmentVarsInScriptPhases),
                  try container.decode(Bool.self, forKey: .disableShowEnvironmentVarsInScriptPhases)
        {
            self = .disableShowEnvironmentVarsInScriptPhases
        } else if container.allKeys.contains(.disablePackageVersionLocking),
                  try container.decode(Bool.self, forKey: .disablePackageVersionLocking)
        {
            self = .disablePackageVersionLocking
        } else if container.allKeys.contains(.resolveDependenciesWithSystemScm),
                  try container.decode(Bool.self, forKey: .resolveDependenciesWithSystemScm)
        {
            self = .resolveDependenciesWithSystemScm
        } else if container.allKeys.contains(.lastXcodeUpgradeCheck),
                  try container.decodeNil(forKey: .lastXcodeUpgradeCheck) == false
        {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .lastXcodeUpgradeCheck)
            let version = try associatedValues.decode(Version.self)
            self = .lastXcodeUpgradeCheck(version)
        } else {
            throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Unknown enum case"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case let .xcodeProjectName(templateProjectName):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .xcodeProjectName)
            try associatedValues.encode(templateProjectName)
        case let .organizationName(name):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .organizationName)
            try associatedValues.encode(name)
        case let .developmentRegion(developmentRegion):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .developmentRegion)
            try associatedValues.encode(developmentRegion)
        case let .autogeneratedWorkspaceSchemes(options):
            try container.encode(options, forKey: .autogeneratedWorkspaceSchemes)
        case .disableShowEnvironmentVarsInScriptPhases:
            try container.encode(true, forKey: .disableShowEnvironmentVarsInScriptPhases)
        case .resolveDependenciesWithSystemScm:
            try container.encode(true, forKey: .resolveDependenciesWithSystemScm)
        case .disablePackageVersionLocking:
            try container.encode(true, forKey: .disablePackageVersionLocking)
        case let .lastXcodeUpgradeCheck(version):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .lastXcodeUpgradeCheck)
            try associatedValues.encode(version)
        }
    }
}

// MARK: - AutogenerrationOptions + Codable

extension Config.GenerationOptions.AutogenerationOptions {
    internal enum CodingKeys: String, CodingKey {
        case enabled
        case targetSchemesGrouping
        case codeCoverageMode
        case testingOptions
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let enabled = try container.decode(Bool.self, forKey: .enabled)
        if enabled {
            let codeCoverageMode = try container.decode(CodeCoverageMode.self, forKey: .codeCoverageMode)
            let testingOptions = try container.decode(TestingOptions.self, forKey: .testingOptions)
            self = .enabled(
                codeCoverageMode: codeCoverageMode,
                testingOptions: testingOptions
            )
        } else {
            self = .disabled
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case let .enabled(codeCoverageMode, testingOptions):
            try container.encode(true, forKey: .enabled)
            try container.encode(codeCoverageMode, forKey: .codeCoverageMode)
            try container.encode(testingOptions, forKey: .testingOptions)
        case .disabled:
            try container.encode(false, forKey: .enabled)
        }
    }
}

// MARK: - CodeCoverrageMode + Codable

extension Config.GenerationOptions.AutogenerationOptions.CodeCoverageMode {
    private enum Kind: String, Codable {
        case all
        case relevant
        case targets
        case disabled
    }

    internal enum CodingKeys: String, CodingKey {
        case kind
        case targets
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let kind = try container.decode(Kind.self, forKey: .kind)
        switch kind {
        case .all:
            self = .all
        case .relevant:
            self = .relevant
        case .targets:
            let targets = try container.decode([TargetReference].self, forKey: .targets)
            self = .targets(targets)
        case .disabled:
            self = .disabled
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .all:
            try container.encode(Kind.all, forKey: .kind)
        case .relevant:
            try container.encode(Kind.relevant, forKey: .kind)
        case let .targets(targets):
            try container.encode(Kind.targets, forKey: .kind)
            try container.encode(targets, forKey: .targets)
        case .disabled:
            try container.encode(Kind.disabled, forKey: .kind)
        }
    }
}
