import Foundation

/// Additional options related to the `Project`
public enum ProjectOption: Codable, Equatable {
    /// Defines how to generate automatic schemes
    case automaticSchemesOptions(AutomaticSchemesOptions)

    /// Disables generating Bundle accessors.
    case disableBundleAccessors

    /// Disable the synthesized resource accessors generation
    case disableSynthesizedResourceAccessors

    /// Text settings to override user ones for current project.
    ///
    /// - Parameters:
    ///   - usesTabs: Use tabs over spaces.
    ///   - indentWidth: Indent width.
    ///   - tabWidth: Tab width.
    ///   - wrapsLines: Wrap lines.
    case textSettings(
        usesTabs: Bool? = nil,
        indentWidth: UInt? = nil,
        tabWidth: UInt? = nil,
        wrapsLines: Bool? = nil
    )
}

// MARK: - AutomaticSchemesOptions

extension ProjectOption {
    /// The automatic schemes options
    public enum AutomaticSchemesOptions: Codable, Equatable {
        /// Enable autogenerated schemes
        case enabled(
            targetSchemesGrouping: TargetSchemesGrouping = .byNameSuffix(
                build: ["Implementation", "Interface", "Mocks", "Testing"],
                test: ["Tests", "IntegrationTests", "UITests", "SnapshotTests"],
                run: ["App", "Demo"]
            ),
            codeCoverageEnabled: Bool = false,
            testingOptions: TestingOptions = []
        )

        /// Disable autogenerated schemes
        case disabled

        /// Defines how to group targets into scheme for autogenerated schemes
        public enum TargetSchemesGrouping: Codable, Equatable {
            /// Generate a single target for the whole project
            case singleScheme

            /// Group the targets according to their name suffixes
            case byNameSuffix(build: Set<String>, test: Set<String>, run: Set<String>)

            /// Do not group targets, create a scheme for each target
            case notGrouped
        }
    }
}

// MARK: - ProjectOption + Codable

extension ProjectOption {
    private enum OptionsCodingKeys: String, CodingKey {
        case automaticSchemesOptions
        case disableBundleAccessors
        case disableSynthesizedResourceAccessors
        case textSettings
    }

    private enum TextSettingsKeys: String, CodingKey {
        case usesTabs
        case indentWidth
        case tabWidth
        case wrapsLines
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: OptionsCodingKeys.self)

        if let options = try container.decodeIfPresent(AutomaticSchemesOptions.self, forKey: .automaticSchemesOptions) {
            self = .automaticSchemesOptions(options)
        } else if container.allKeys.contains(.disableBundleAccessors) {
            self = .disableBundleAccessors
        } else if container.allKeys.contains(.disableSynthesizedResourceAccessors) {
            self = .disableSynthesizedResourceAccessors
        } else if container.allKeys.contains(.textSettings), try container.decodeNil(forKey: .textSettings) == false {
            let textSettingsContainer = try container.nestedContainer(
                keyedBy: TextSettingsKeys.self,
                forKey: .textSettings
            )

            self = .textSettings(
                usesTabs: try textSettingsContainer.decodeIfPresent(Bool.self, forKey: .usesTabs),
                indentWidth: try textSettingsContainer.decodeIfPresent(UInt.self, forKey: .indentWidth),
                tabWidth: try textSettingsContainer.decodeIfPresent(UInt.self, forKey: .tabWidth),
                wrapsLines: try textSettingsContainer.decodeIfPresent(Bool.self, forKey: .wrapsLines)
            )
        } else {
            throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Unknown enum case"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: OptionsCodingKeys.self)

        switch self {
        case let .automaticSchemesOptions(options):
            try container.encode(options, forKey: .automaticSchemesOptions)
        case .disableBundleAccessors:
            try container.encode(true, forKey: .disableBundleAccessors)
        case .disableSynthesizedResourceAccessors:
            try container.encode(true, forKey: .disableSynthesizedResourceAccessors)
        case let .textSettings(usesTabs, indentWidth, tabWidth, wrapsLines):
            var associatedValues = container.nestedContainer(keyedBy: TextSettingsKeys.self, forKey: .textSettings)
            try associatedValues.encodeIfPresent(usesTabs, forKey: .usesTabs)
            try associatedValues.encodeIfPresent(indentWidth, forKey: .indentWidth)
            try associatedValues.encodeIfPresent(tabWidth, forKey: .tabWidth)
            try associatedValues.encodeIfPresent(wrapsLines, forKey: .wrapsLines)
        }
    }
}

// MARK: - AutomaticSchemesOptions + Codable

extension ProjectOption.AutomaticSchemesOptions {
    internal enum CodingKeys: String, CodingKey {
        case enabled
        case targetSchemesGrouping
        case codeCoverageEnabled
        case testingOptions
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let enabled = try container.decode(Bool.self, forKey: .enabled)
        if enabled {
            let targetSchemesGrouping = try container.decode(TargetSchemesGrouping.self, forKey: .targetSchemesGrouping)
            let codeCoverageEnabled = try container.decode(Bool.self, forKey: .codeCoverageEnabled)
            let testingOptions = try container.decode(TestingOptions.self, forKey: .testingOptions)
            self = .enabled(
                targetSchemesGrouping: targetSchemesGrouping,
                codeCoverageEnabled: codeCoverageEnabled,
                testingOptions: testingOptions
            )
        } else {
            self = .disabled
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case let .enabled(targetSchemesGrouping, codeCoverageEnabled, testingOptions):
            try container.encode(true, forKey: .enabled)
            try container.encode(targetSchemesGrouping, forKey: .targetSchemesGrouping)
            try container.encode(codeCoverageEnabled, forKey: .codeCoverageEnabled)
            try container.encode(testingOptions, forKey: .testingOptions)
        case .disabled:
            try container.encode(false, forKey: .enabled)
        }
    }
}

// MARK: - TargetSchemesGrouping + Codable

extension TargetSchemesGrouping {
    private enum Kind: String, Codable {
        case singleScheme
        case byNameSuffix
        case notGrouped
    }

    internal enum CodingKeys: String, CodingKey {
        case kind
        case buildSuffix
        case testSuffix
        case runSuffix
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let kind = try container.decode(Kind.self, forKey: .kind)
        switch kind {
        case .singleScheme:
            self = .singleScheme
        case .byNameSuffix:
            let buildSuffix = try container.decode(Set<String>.self, forKey: .buildSuffix)
            let testSuffix = try container.decode(Set<String>.self, forKey: .testSuffix)
            let runSuffix = try container.decode(Set<String>.self, forKey: .runSuffix)
            self = .byNameSuffix(build: buildSuffix, test: testSuffix, run: runSuffix)
        case .notGrouped:
            self = .notGrouped
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .singleScheme:
            try container.encode(Kind.singleScheme, forKey: .kind)
        case let .byNameSuffix(buildSuffix, testSuffix, runSuffix):
            try container.encode(Kind.byNameSuffix, forKey: .kind)
            try container.encode(buildSuffix, forKey: .buildSuffix)
            try container.encode(testSuffix, forKey: .testSuffix)
            try container.encode(runSuffix, forKey: .runSuffix)
        case .notGrouped:
            try container.encode(Kind.notGrouped, forKey: .kind)
        }
    }
}

public enum TargetSchemesGrouping: Codable, Equatable {
    /// Generate a single target for the whole project
    case singleScheme

    /// Group the targets according to their name suffixes
    case byNameSuffix(build: Set<String>, test: Set<String>, run: Set<String>)

    /// Do not group targets, create a scheme for each target
    case notGrouped
}
