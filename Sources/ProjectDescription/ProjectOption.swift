import Foundation

/// Additional options related to the `Project`
public enum ProjectOption: Codable, Equatable {
    /// Defines how to group targets into scheme for autogenerated schemes
    public enum AutomaticSchemesGrouping: Codable, Equatable {
        /// Group all the targets of the project in a single scheme
        case singleScheme

        /// Group the targets according to their name suffixes
        case byNameSuffix(build: Set<String>, test: Set<String>, run: Set<String>)

        /// Do not group targets, create a scheme for each target
        case notGrouped
    }

    /// Defines how to group automatically generated schemes
    case automaticSchemesGrouping(AutomaticSchemesGrouping)

    /// Disables generating Bundle accessors.
    case disableBundleAccessors

    /// Disable the synthesized resource accessors generation
    case disableSynthesizedResourceAccessors

    /// Text settings to override user ones for current project.
    ///
    /// - Parameters:
    ///   - usesTabs: Use tabs over spaces.
    ///   - indentWidth: Indent width.
    ///   - tabWidth: Tab width.
    ///   - wrapsLines: Wrap lines.
    case textSettings(
        usesTabs: Bool? = nil,
        indentWidth: UInt? = nil,
        tabWidth: UInt? = nil,
        wrapsLines: Bool? = nil
    )
}

// MARK: - Options + Codable

extension ProjectOption {
    private enum OptionsCodingKeys: String, CodingKey {
        case automaticSchemesGrouping
        case disableBundleAccessors
        case disableSynthesizedResourceAccessors
        case textSettings
    }

    private enum TextSettingsKeys: String, CodingKey {
        case usesTabs
        case indentWidth
        case tabWidth
        case wrapsLines
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: OptionsCodingKeys.self)

        if let grouping = try container.decodeIfPresent(AutomaticSchemesGrouping.self, forKey: .automaticSchemesGrouping) {
            self = .automaticSchemesGrouping(grouping)
        } else if container.allKeys.contains(.disableBundleAccessors) {
            self = .disableBundleAccessors
        } else if container.allKeys.contains(.disableSynthesizedResourceAccessors) {
            self = .disableSynthesizedResourceAccessors
        } else if container.allKeys.contains(.textSettings), try container.decodeNil(forKey: .textSettings) == false {
            let textSettingsContainer = try container.nestedContainer(
                keyedBy: TextSettingsKeys.self,
                forKey: .textSettings
            )

            self = .textSettings(
                usesTabs: try textSettingsContainer.decodeIfPresent(Bool.self, forKey: .usesTabs),
                indentWidth: try textSettingsContainer.decodeIfPresent(UInt.self, forKey: .indentWidth),
                tabWidth: try textSettingsContainer.decodeIfPresent(UInt.self, forKey: .tabWidth),
                wrapsLines: try textSettingsContainer.decodeIfPresent(Bool.self, forKey: .wrapsLines)
            )
        } else {
            throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Unknown enum case"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: OptionsCodingKeys.self)

        switch self {
        case let .automaticSchemesGrouping(grouping):
            try container.encode(grouping, forKey: .automaticSchemesGrouping)
        case .disableBundleAccessors:
            try container.encode(true, forKey: .disableBundleAccessors)
        case .disableSynthesizedResourceAccessors:
            try container.encode(true, forKey: .disableSynthesizedResourceAccessors)
        case let .textSettings(usesTabs, indentWidth, tabWidth, wrapsLines):
            var associatedValues = container.nestedContainer(keyedBy: TextSettingsKeys.self, forKey: .textSettings)
            try associatedValues.encodeIfPresent(usesTabs, forKey: .usesTabs)
            try associatedValues.encodeIfPresent(indentWidth, forKey: .indentWidth)
            try associatedValues.encodeIfPresent(tabWidth, forKey: .tabWidth)
            try associatedValues.encodeIfPresent(wrapsLines, forKey: .wrapsLines)
        }
    }
}
