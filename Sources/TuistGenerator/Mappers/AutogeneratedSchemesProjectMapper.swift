import Foundation
import TSCBasic
import TuistCore
import TuistGraph

/// A project mapper that auto-generates schemes for each of the targets of the `Project`
/// if the user hasn't already defined schemes for those.
public final class AutogeneratedSchemesProjectMapper: ProjectMapping {
    // MARK: - Init

    public init() {}

    // MARK: - ProjectMapping

    public func map(project: Project) throws -> (Project, [SideEffectDescriptor]) {
        let userDefinedSchemes = project.schemes
        let userDefinedSchemeNames = Set(project.schemes.map(\.name))

        var buildTargets: Set<Target> = []
        var testTargets: Set<Target> = []
        var runTargets: Set<Target> = []
        project.targets.forEach { target in
            if target.product.runnable {
                runTargets.insert(target)
            } else if target.product.testsBundle {
                testTargets.insert(target)
            } else {
                buildTargets.insert(target)
            }
        }

        let targetGroups: [String: (build: Set<Target>, test: Set<Target>, run: Target?)]
        switch project.options.targetSchemesGrouping {
        case .singleScheme:
            targetGroups = [
                project.name: (
                    build: buildTargets.union(runTargets.count > 1 ? runTargets : []),
                    test: testTargets,
                    run: runTargets.count == 1 ? runTargets.first! : nil
                ),
            ]
            buildTargets = []
            testTargets = []
            runTargets = []
        case let .byNameSuffix(buildSuffixes, testSuffixes, runSuffixes):
            targetGroups = groupByName(
                buildTargets: &buildTargets,
                testTargets: &testTargets,
                runTargets: &runTargets,
                buildSuffixes: buildSuffixes,
                testSuffixes: testSuffixes,
                runSuffixes: runSuffixes
            )
        case .notGrouped:
            targetGroups = [:]
        case .none:
            targetGroups = [:]
            buildTargets = []
            testTargets = []
            runTargets = []
        }

        // create groups schemes
        let targetGroupsSchemes = targetGroups.map { name, targets in
            createDefaultScheme(
                name: name,
                project: project,
                buildTargets: targets.build.map { .init(projectPath: project.path, name: $0.name) },
                testTargets: targets.test.map { .init(projectPath: project.path, name: $0.name) },
                runTarget: targets.run,
                buildConfiguration: project.defaultDebugBuildConfigurationName
            )
        }
        // create ungrouped targets schemes
        let remainingBuildTargetsSchemes = buildTargets.map {
            createDefaultScheme(
                name: $0.name,
                project: project,
                buildTargets: [.init(projectPath: project.path, name: $0.name)],
                buildConfiguration: project.defaultDebugBuildConfigurationName
            )
        }
        let remainingTestTargetsSchemes = testTargets.map {
            createDefaultScheme(
                name: $0.name,
                project: project,
                buildTargets: [.init(projectPath: project.path, name: $0.name)],
                testTargets: [.init(projectPath: project.path, name: $0.name)],
                buildConfiguration: project.defaultDebugBuildConfigurationName
            )
        }
        let remainingRunTargetsSchemes = runTargets.map {
            createDefaultScheme(
                name: $0.name,
                project: project,
                buildTargets: [.init(projectPath: project.path, name: $0.name)],
                runTarget: $0,
                buildConfiguration: project.defaultDebugBuildConfigurationName
            )
        }

        let autogeneratedSchemes = targetGroupsSchemes + remainingBuildTargetsSchemes + remainingTestTargetsSchemes +
            remainingRunTargetsSchemes
            .filter { !userDefinedSchemeNames.contains($0.name) }
        return (project.with(schemes: (userDefinedSchemes + autogeneratedSchemes).sorted { $0.name < $1.name }), [])
    }

    // MARK: - Private

    private func createDefaultScheme(
        name: String,
        project: Project,
        buildTargets: [TargetReference],
        testTargets: [TargetReference] = [],
        runTarget: Target? = nil,
        buildConfiguration: String
    ) -> Scheme {
        let runAction: RunAction?
        if let runTarget = runTarget {
            runAction = .init(
                configurationName: buildConfiguration,
                attachDebugger: true,
                preActions: [],
                postActions: [],
                executable: .init(projectPath: project.path, name: runTarget.name),
                filePath: nil,
                arguments: defaultArguments(for: runTarget),
                diagnosticsOptions: [.mainThreadChecker]
            )
        } else {
            runAction = nil
        }

        return Scheme(
            name: name,
            shared: true,
            buildAction: BuildAction(
                targets: (buildTargets + testTargets + (runAction?.executable.map { [$0] } ?? [])).sorted { $0.name < $1.name }
            ),
            testAction: testTargets.isEmpty ? nil : TestAction(
                targets: testTargets.map { TestableTarget(target: $0) }.sorted(by: { $0.target.name < $1.target.name }),
                arguments: nil,
                configurationName: buildConfiguration,
                attachDebugger: true,
                coverage: project.options.codeCoverageEnabled,
                codeCoverageTargets: [],
                expandVariableFromTarget: nil,
                preActions: [],
                postActions: [],
                diagnosticsOptions: [.mainThreadChecker]
            ),
            runAction: runAction
        )
    }

    private func defaultArguments(for target: Target) -> Arguments? {
        if target.environment.isEmpty, target.launchArguments.isEmpty {
            return nil
        }
        return Arguments(environment: target.environment, launchArguments: target.launchArguments)
    }

    private func groupByName(
        buildTargets: inout Set<Target>,
        testTargets: inout Set<Target>,
        runTargets: inout Set<Target>,
        buildSuffixes: Set<String>,
        testSuffixes: Set<String>,
        runSuffixes: Set<String>
    ) -> [String: (build: Set<Target>, test: Set<Target>, run: Target?)] {
        let longerFirst: (String, String) -> Bool = { $0.count > $1.count }
        let sortedBuildSuffixes = (buildSuffixes + [""]).sorted(by: longerFirst)
        let sortedTestSuffixes = (testSuffixes + [""]).sorted(by: longerFirst)
        let sortedRunSuffixes = (runSuffixes + [""]).sorted(by: longerFirst)
        let groupToBuildTargets: [String: Set<Target>] = buildTargets
            .map { target -> (name: String, target: Target) in
                for buildSuffix in sortedBuildSuffixes {
                    if target.name.hasSuffix(buildSuffix) {
                        let groupName = String(target.name.dropSuffix(buildSuffix))
                        buildTargets.remove(target)
                        return (name: groupName, target: target)
                    }
                }
                return (name: target.name, target: target)
            }
            .reduce(into: [:]) { result, nameAndTarget in
                result[nameAndTarget.name, default: []].insert(nameAndTarget.target)
            }

        let groupToTestTargets: [String: Set<Target>] = testTargets
            .map { target -> (name: String, target: Target) in
                for testSuffix in sortedTestSuffixes {
                    if target.name.hasSuffix(testSuffix) {
                        let groupName = String(target.name.dropSuffix(testSuffix))
                        testTargets.remove(target)
                        return (name: groupName, target: target)
                    }
                }
                return (name: target.name, target: target)
            }
            .reduce(into: [:]) { result, nameAndTarget in
                result[nameAndTarget.name, default: []].insert(nameAndTarget.target)
            }

        let groupToRunTarget: [String: Target] = runTargets
            .reduce(into: [:]) { result, target in
                for runSuffix in sortedRunSuffixes {
                    if target.name.hasSuffix(runSuffix) {
                        let groupName = String(target.name.dropSuffix(runSuffix))
                        runTargets.remove(target)
                        result[groupName] = target
                        return
                    }
                }
                result[target.name] = target
            }

        let allGroupNames = Set(groupToBuildTargets.keys).union(groupToTestTargets.keys).union(groupToRunTarget.keys)
        return Dictionary(uniqueKeysWithValues: allGroupNames.map { name in
            (
                name,
                (
                    build: groupToBuildTargets[name] ?? [],
                    test: groupToTestTargets[name] ?? [],
                    run: groupToRunTarget[name]
                )
            )
        })
    }
}
