import Foundation
import ProjectDescription

/// Additional options related to the `Project`
public enum ProjectOption: Codable {
    /// Defines how to group targets in automatically generated schemes
    case automaticSchemesOptions(AutomaticSchemesOptions)

    /// Disables generating Bundle accessors.
    case disableBundleAccessors

    /// Disable the synthesized resource accessors generation
    case disableSynthesizedResourceAccessors

    /// Text settings to override user ones for current project
    case textSettings(TextSettings)

    /// Option name
    public var name: String {
        switch self {
        case .automaticSchemesOptions:
            return "automaticSchemesOptions"
        case .disableBundleAccessors:
            return "disableBundleAccessors"
        case .disableSynthesizedResourceAccessors:
            return "disableSynthesizedResourceAccessors"
        case .textSettings:
            return "textSettings"
        }
    }
}

// MARK: - Array + ProjectOption

extension ProjectOption {
    /// The automatic schemes options
    public enum AutomaticSchemesOptions: Codable {
        /// Enable autogenerated schemes
        case enabled(
            targetSchemesGrouping: TargetSchemesGrouping,
            codeCoverageEnabled: Bool,
            testingOptions: TestingOptions
        )

        /// Disable autogenerated schemes
        case disabled

        /// Defines how to group targets into scheme for autogenerated schemes
        public enum TargetSchemesGrouping: Codable {
            /// Generate a single scheme per project
            case singleScheme

            /// Group the targets according to their name suffixes
            case byNameSuffix(build: Set<String>, test: Set<String>, run: Set<String>)

            /// Do not group targets, create a scheme for each target
            case notGrouped
        }
    }
}

// MARK: - Array + ProjectOption

extension Array where Element == ProjectOption {
    public var automaticSchemesOptions: ProjectOption.AutomaticSchemesOptions {
        compactMap {
            switch $0 {
            case let .automaticSchemesOptions(options):
                return options
            case .disableBundleAccessors, .disableSynthesizedResourceAccessors, .textSettings:
                return nil
            }
        }.first ?? .disabled
    }

    public var targetSchemesGrouping: ProjectOption.AutomaticSchemesOptions.TargetSchemesGrouping? {
        switch automaticSchemesOptions {
        case let .enabled(targetSchemesGrouping, _, _):
            return targetSchemesGrouping
        case .disabled:
            return nil
        }
    }

    public var codeCoverageEnabled: Bool {
        switch automaticSchemesOptions {
        case let .enabled(_, codeCoverageEnabled, _):
            return codeCoverageEnabled
        case .disabled:
            return false
        }
    }

    public var testingOptions: TestingOptions {
        switch automaticSchemesOptions {
        case let .enabled(_, _, testingOptions):
            return testingOptions
        case .disabled:
            return []
        }
    }

    public var disableBundleAccessors: Bool {
        contains(.disableBundleAccessors)
    }

    public var disableSynthesizedResourceAccessors: Bool {
        contains(.disableSynthesizedResourceAccessors)
    }

    public var textSettings: TextSettings? {
        compactMap {
            switch $0 {
            case .automaticSchemesOptions, .disableBundleAccessors, .disableSynthesizedResourceAccessors:
                return nil
            case let .textSettings(textSettings):
                return textSettings
            }
        }.first
    }
}

// MARK: - Options + Hashable

extension ProjectOption: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }

    public static func == (lhs: ProjectOption, rhs: ProjectOption) -> Bool {
        switch (lhs, rhs) {
        case (.automaticSchemesOptions, .automaticSchemesOptions),
             (.disableBundleAccessors, .disableBundleAccessors),
             (.disableSynthesizedResourceAccessors, .disableSynthesizedResourceAccessors),
             (.textSettings, .textSettings):
            return true
        case (.automaticSchemesOptions, _), (.disableBundleAccessors, _), (.disableSynthesizedResourceAccessors, _),
             (.textSettings, _):
            return false
        }
    }
}

// MARK: - ProjectOption + Codable

extension ProjectOption {
    internal enum CodingKeys: String, CodingKey {
        case automaticSchemesOptions
        case disableBundleAccessors
        case disableSynthesizedResourceAccessors
        case textSettings
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        if container.allKeys.contains(.automaticSchemesOptions),
           try container.decodeNil(forKey: .automaticSchemesOptions) == false
        {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .automaticSchemesOptions)
            let automaticSchemesOptions = try associatedValues.decode(AutomaticSchemesOptions.self)
            self = .automaticSchemesOptions(automaticSchemesOptions)
        } else if container.contains(.disableBundleAccessors) {
            self = .disableBundleAccessors
        } else if container.contains(.disableSynthesizedResourceAccessors) {
            self = .disableSynthesizedResourceAccessors
        } else if container.allKeys.contains(.textSettings), try container.decodeNil(forKey: .textSettings) == false {
            var associatedValues = try container.nestedUnkeyedContainer(forKey: .textSettings)
            let textSettings = try associatedValues.decode(TextSettings.self)
            self = .textSettings(textSettings)
        } else {
            throw DecodingError.dataCorrupted(.init(codingPath: decoder.codingPath, debugDescription: "Unknown enum case"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case let .automaticSchemesOptions(options):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .automaticSchemesOptions)
            try associatedValues.encode(options)
        case .disableBundleAccessors:
            try container.encode(true, forKey: .disableBundleAccessors)
        case .disableSynthesizedResourceAccessors:
            try container.encode(true, forKey: .disableSynthesizedResourceAccessors)
        case let .textSettings(textSettings):
            var associatedValues = container.nestedUnkeyedContainer(forKey: .textSettings)
            try associatedValues.encode(textSettings)
        }
    }
}
